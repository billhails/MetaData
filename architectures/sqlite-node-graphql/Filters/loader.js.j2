{#-
 #  MetaData - API Generator.
 #  Copyright (C) 2022  Bill Hails
 #
 #  This program is free software: you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License as published by
 #  the Free Software Foundation, either version 3 of the License, or
 #  (at your option) any later version.
 #
 #  This program is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #  GNU General Public License for more details.
 #
 #  You should have received a copy of the GNU General Public License
 #  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-#}
// {{ warning }}

{%- import 'macros/loader.j2h' as loader %}
{%- import 'macros/data.j2h' as data %}
{%- import 'macros/database.j2h' as database %}
{%- import 'macros/gql.j2h' as gql %}

const DataLoader = require('dataloader');
const util = require('util');
const logger = require('../Utils/logger');
const object_hash = require('object-hash');

class EntityLoader {
    constructor({loader, page_get, name}) {
        this.loader = loader;
        this.page_get = page_get;
        this.name = name;
    }

    async load (args) {
        this.debug('args', args);
        const entities = await this.page_get(args);
        entities.forEach(entity => this.loader().prime(entity.id, entity));
        return entities;
    }

    debug(msg, args) {
        logger.debug(`loader.EntityLoader.${this.name} ${msg} ${util.inspect(args)}`);
    }

    clearAll() {
        this.loader().clearAll();
    }
}

class EntityCountLoader {
    constructor({page_get}) {
        this.page_get = page_get;
    }

    async load (args) {
        return this.page_get(args);
    }

    clearAll() {}
}

class AbstractLoader {
    constructor({batch_get, name}) {
        this.lookup = {};
        this.batch_get = batch_get;
        this.name = name;
        this.loader = new DataLoader(async keys => this.loadBatch(keys));
    }

    async load(id, args) {
        const data = {id, args};
        const key = object_hash(data);
        this.lookup[key] = {id, args, key};
        return this.loader.load(key);
    }

    debug(msg, args) {
        logger.debug(`loader.${this.constructor.name}.${this.name} ${msg} ${util.inspect(args)}`);
    }

    clearAll() {
        this.loader.clearAll();
    }
}

class ReferrerLoader extends AbstractLoader {
    constructor({name, batch_get, entity_loader, referrer_column}) {
        super({batch_get, name});
        this.entity_loader = entity_loader;
        this.referrer_column = referrer_column;
    }

    async loadBatch(keys) {
        this.debug('started', {keys, batch_get: this.batch_get});
        const ids_and_args = keys.map(key => this.lookup[key]);
        this.debug('got ids_and_args', ids_and_args);
        const referrers = await this.batch_get(ids_and_args);
        this.debug('got referrers', referrers);
        referrers.forEach(referrer => this.entity_loader().prime(referrer.id, referrer));
        return ids_and_args.map(({id}) => { // maps [lhs_id, lhs_id, ... ] to [[rhs_entity, rhs_entity, ...], [rhs_entity, ...], ...]
            const id_referrers = {};
            referrers.forEach(
                referrer => {
                    if (referrer[this.referrer_column] == id) {
                        id_referrers[referrer.id] = referrer;
                    }
                }
            );
            return Object.values(id_referrers);
        });
    }
}

class ReferrerCountLoader extends AbstractLoader {

    async loadBatch(keys) {
        this.debug('started', {keys});
        const ids_and_args = keys.map(key => this.lookup[key]);
        this.debug('got ids_and_args', ids_and_args);
        const referrerCounts = await this.batch_get(ids_and_args);
        this.debug('got raw referrer counts', referrerCounts);
        const processedCounts = referrerCounts.reduce((acc, count) => ({...acc, [count.id]: count.count}), {});
        this.debug(`got referrer counts`, processedCounts);
        return ids_and_args.map(({id}) => ({ count: processedCounts[id] || 0}));
    }
}

class SelfReferentialAssociationLoader extends AbstractLoader {
    constructor({name, batch_get, lhs_column, rhs_column}) {
        super({batch_get, name});
        this.lhs_column = lhs_column;
        this.rhs_column = rhs_column;
    }

    async loadBatch(keys) {
        this.debug('started', {keys, batch_get: this.batch_get});
        const ids_and_args = keys.map(key => this.lookup[key])
        const associations = await this.batch_get(ids_and_args);
        this.debug(`got associations`, associations);
        return ids_and_args.map(({id}) => {
            const associates = {};
            associations.forEach(association => {
                if (association[this.lhs_column] == id) {
                    associates[association[this.rhs_column]] = true;
                }
                if (association[this.rhs_column] == id) {
                    associates[association[this.lhs_column]] = true;
                }
            });
            return Object.keys(associates);
        });
    }
}

class AssociationLoader extends AbstractLoader {
    constructor({name, batch_get, this_column, other_column}) {
        super({batch_get, name});
        this.this_column = this_column;
        this.other_column = other_column;
    }

    async loadBatch(keys) {
        this.debug('started', {keys, batch_get: this.batch_get});
        const ids_and_args = keys.map(key => this.lookup[key]);
        this.debug('ids and args', ids_and_args);
        const associations = await this.batch_get(ids_and_args);
        this.debug(`got associations ${util.inspect({associations})}`);
        const result = ids_and_args.map(({id}) => {
            const associates = {};
            associations.forEach(association => {
                if (association[this.this_column] == id) {
                    associates[association[this.other_column]] = true;
                }
            });
            return Object.keys(associates);
        });
        this.debug('returning', result);
        return result;
    }
}

class AssociationCountLoader extends AbstractLoader {
    async loadBatch(keys) {
        this.debug('started', {keys});
        const ids_and_args = keys.map(key => this.lookup[key]);
        this.debug('ids and args', ids_and_args);
        const associationCounts = await this.batch_get(ids_and_args);
        this.debug('got raw association counts', associationCounts);
        const processedCounts = associationCounts.reduce((acc, count) => ({...acc, [count.id]: count.count}), {});
        this.debug('got association counts', processedCounts);
        return ids_and_args.map(({id}) => processedCounts[id] || 0);
    }
}

class SelfReferentialAssociationCountLoader extends AbstractLoader {
    async loadBatch(keys) {
        this.debug('started', {keys});
        const ids_and_args = keys.map(key => this.lookup[key]);
        this.debug('ids and args', ids_and_args);
        const associationCounts = await this.batch_get(ids_and_args);
        this.debug('got raw association counts', associationCounts);
        const processedCounts = {};
        associationCounts.forEach(count => {
            if (!(count.id in processedCounts)) {
                processedCounts[count.id] = 0;
            }
            processedCounts[count.id] += count.count;
        });
        this.debug('got association counts', processedCounts);
        return ids_and_args.map(({id}) => processedCounts[id] || 0);
    }
}

module.exports = (data) => {
{%- for entity in schema.get_entities() %}

    const {{ loader.entity(entity) }} = new DataLoader(async ids => {
        logger.debug(`loader.{{ loader.entity(entity) }} got ids ${util.inspect(ids)}`);
        return data.{{ data.batch_get_entity(entity) }}(ids);
    });

    const {{ loader.entities(entity) }} = new EntityLoader({
        loader: () => {{ loader.entity(entity) }},
        page_get: async args => data.{{ data.page_get_entity(entity) }}(args),
        name: '{{ loader.entities(entity) }}'
    });

    const {{ loader.count_entities(entity) }} = new EntityCountLoader({
        page_get: async args => data.{{ data.count_entities(entity) }}(args)
    });

{%-     for referrer in entity.get_referrers() %}

    const {{ loader.referrer(referrer) }} = new ReferrerLoader({
        batch_get: async (ids_and_args) => data.{{ data.batch_get_referrer(referrer) }}(ids_and_args),
        entity_loader: () => {{ loader.entity(referrer.get_entity()) }},
        referrer_column: '{{ referrer.get_column_name() }}',
        name: '{{ loader.referrer(referrer) }}'
    });

    const {{ loader.count_referrer(referrer) }} = new ReferrerCountLoader({
        name: '{{ loader.count_referrer(referrer) }}',
        batch_get: async (ids_and_args) => data.{{ data.batch_count_referrer(referrer) }}(ids_and_args)
    });
{%-     endfor %}

{%-     for association in entity.get_associations() %}

{%-         if association.is_self_referential() %}

    const {{ loader.association_for_entity(entity, association) }} = new SelfReferentialAssociationLoader({
        batch_get: async (ids_and_args) => data.{{ data.batch_get_association(entity, association) }}(ids_and_args),
        lhs_column: '{{ gql.lhs(association) }}',
        rhs_column: '{{ gql.rhs(association) }}',
        name: '{{ loader.association_for_entity(entity, association) }}'
    });

    const {{ loader.count_association_for_entity(entity, association) }} = new SelfReferentialAssociationCountLoader({
        name: '{{ loader.count_association_for_entity(entity, association) }}',
        batch_get: async (ids_and_args) => data.{{ data.batch_count_association(entity, association) }}(ids_and_args)
    });

{%-         else %}

    const {{ loader.association_for_entity(entity, association) }} = new AssociationLoader({
        batch_get: async (ids_and_args) => data.{{ data.batch_get_association(entity, association) }}(ids_and_args),
        this_column: '{{ gql.this_column(entity, association) }}',
        other_column: '{{ gql.other_column(entity, association) }}',
        name: '{{ loader.association_for_entity(entity, association) }}'
    });

    const {{ loader.count_association_for_entity(entity, association) }} = new AssociationCountLoader({
        name: '{{ loader.count_association_for_entity(entity, association) }}',
        batch_get: async ids_and_args => data.{{ data.batch_count_association(entity, association) }}(ids_and_args)
    });
{%-         endif %}
{%-     endfor %}
{%- endfor %}

    const clearAll = () => {
{%- for entity in schema.get_entities() %}
        {{ loader.entity(entity) }}.clearAll();
        {{ loader.entities(entity) }}.clearAll();
{%-     for referrer in entity.get_referrers() %}
        {{ loader.referrer(referrer) }}.clearAll();
        {{ loader.count_referrer(referrer) }}.clearAll();
{%-     endfor %}
{%-     for association in entity.get_associations() %}
        {{ loader.association_for_entity(entity, association) }}.clearAll();
        {{ loader.count_association_for_entity(entity, association) }}.clearAll();
{%-     endfor %}
{%- endfor %}
    };

    return {
{%- for entity in schema.get_entities() %}
        {{ loader.entity(entity) }},
        {{ loader.entities(entity) }},
        {{ loader.count_entities(entity) }},
{%-     for referrer in entity.get_referrers() %}
        {{ loader.referrer(referrer) }},
        {{ loader.count_referrer(referrer) }},
{%-     endfor %}
{%-     for association in entity.get_associations() %}
        {{ loader.association_for_entity(entity, association) }},
        {{ loader.count_association_for_entity(entity, association) }},
{%-     endfor %}
{%- endfor %}
        data,
        clearAll
    };
};