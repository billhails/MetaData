{#
 #  MetaData - API Generator.
 #  Copyright (C) 2022  Bill Hails
 #
 #  This program is free software: you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License as published by
 #  the Free Software Foundation, either version 3 of the License, or
 #  (at your option) any later version.
 #
 #  This program is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #  GNU General Public License for more details.
 #
 #  You should have received a copy of the GNU General Public License
 #  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 #}
// {{ warning }}

{% import 'macros/loader.j2h' as loader %}
{% import 'macros/data.j2h' as data %}
{% import 'macros/database.j2h' as database %}
{% import 'macros/schema.j2h' as arguments %}

const DataLoader = require('dataloader');
const util = require('util');
const logger = require('./logger');
const object_hash = require('object-hash');

class EntityLoader {
    constructor({loader, page_get}) {
        this.loader = loader;
        this.page_get = page_get;
    }

    async load (args) {
        const entities = await this.page_get(args);
        entities.forEach(entity => this.loader().prime(entity.id, entity));
        return entities;
    }
}

class EntityCountLoader {
    constructor({page_get}) {
        this.page_get = page_get;
    }

    async load (args) {
        return this.page_get(args);
    }
}

class AbstractLoader {
    constructor(batch_get, name) {
        this.lookup = {};
        this.batch_get = batch_get;
        this.name = name;
        this.loader = null;
    }

    async load(id, args) {
        const data = {id, args};
        const key = object_hash(data);
        this.lookup[key] = {id, args, key};
        return this.loader.load(key);
    }

    debug(msg, args) {
        logger.debug(`${this.name} ${msg} ${util.inspect(args)}`);
    }

    clearAll() {
        this.loader.clearAll();
    }
}

class ReferrerLoader extends AbstractLoader {
    constructor({name, batch_get, entity_loader, referrer_column}) {
        super(batch_get, name);
        this.entity_loader = entity_loader;
        this.referrer_column = referrer_column;
        const that = this;
        this.loader = new DataLoader(
            async keys => {
                that.debug('started', {keys, batch_get: that.batch_get});
                const ids_and_args = keys.map(key => that.lookup[key]);
                that.debug('got ids_and_args', ids_and_args);
                const referrers = await that.batch_get(ids_and_args);
                that.debug('got referrers', referrers);
                referrers.forEach(referrer => that.entity_loader().prime(referrer.id, referrer));
                return ids_and_args.map(({id}) => { // maps [lhs_id, lhs_id, ... ] to [[rhs_entity, rhs_entity, ...], [rhs_entity, ...], ...]
                    const id_referrers = {};
                    referrers.forEach(
                        referrer => {
                            if (referrer[that.referrer_column] == id) {
                                id_referrers[referrer.id] = referrer;
                            }
                        }
                    );
                    return Object.values(id_referrers);
                });
            }
        );
    }
}

class ReferrerCountLoader extends AbstractLoader {
    constructor({name, batch_get, referrer_column}) {
        super(batch_get, name);
        this.referrer_column = referrer_column;
        const that = this;
        this.loader = new DataLoader(
            async keys => {
                that.debug('started', {keys});
                const ids_and_args = keys.map(key => that.lookup[key]);
                that.debug('got ids_and_args', ids_and_args);
                const referrerCounts = await that.batch_get(ids_and_args);
                that.debug('got raw referrer counts', referrerCounts);
                const processedCounts = referrerCounts.reduce((acc, count) => ({...acc, [count[that.referrer_column]]: count.count}), {});
                that.debug(`got referrer counts (${that.referrer_column})`, processedCounts);
                return ids_and_args.map(({id}) => ({ count: processedCounts[id] || 0}));
            }
        );
    }
}

class SelfReferentialAssociationLoader extends AbstractLoader {
    constructor({name, batch_get, lhs_column, rhs_column}) {
        super(batch_get, name);
        this.lhs_column = lhs_column;
        this.rhs_column = rhs_column;
        const that = this;
        this.loader = new DataLoader(
            async keys => {
                that.debug('started', {keys, batch_get: that.batch_get});
                const ids_and_args = keys.map(key => that.lookup[key])
                const associations = await that.batch_get(ids_and_args);
                that.debug(`got associations`, associations);
                return ids_and_args.map(({id}) => {
                    const associates = {};
                    associations.forEach(association => {
                        if (association[that.lhs_column] == id) {
                            associates[association[that.rhs_column]] = true;
                        }
                        if (association[that.rhs_column] == id) {
                            associates[association[that.lhs_column]] = true;
                        }
                    });
                    return Object.keys(associates);
                });
            }
        );
    }
}

class AssociationLoader extends AbstractLoader {
    constructor({name, batch_get, this_column, other_column}) {
        super(batch_get, name);
        this.this_column = this_column;
        this.other_column = other_column;
        const that = this;
        this.loader = new DataLoader(async keys => {
            that.debug('started', {keys, batch_get: that.batch_get});
            const ids_and_args = keys.map(key => that.lookup[key]);
            that.debug('ids and args', ids_and_args);
            const associations = await that.batch_get(ids_and_args);
            that.debug(`got associations ${util.inspect(associations)}`);
            return ids_and_args.map(({id}) => {
                const associates = {};
                associations.forEach(association => {
                    if (association[that.this_column] == id) {
                        associates[association[that.other_column]] = true;
                    }
                });
                return Object.keys(associates);
            });
        });
    }
}

module.exports = (data) => {
{% for entity in schema.get_entities() %}
    const {{ loader.entity(entity) }} = new DataLoader(async ids => data.{{ data.batch_get_entity(entity) }}(ids));

    const {{ loader.entities(entity) }} = new EntityLoader({
        loader: () => {{ entity.get_name() | singular }}Loader,
        page_get: async args => data.{{ data.page_get_entity(entity) }}(args)
    });

    const {{ loader.count_entities(entity) }} = new EntityCountLoader({
        page_get: async args => data.{{ data.count_entities(entity) }}(args)
    });

{%     for referrer in entity.get_referrers() %}
    const {{ loader.referrer(referrer) }} = new ReferrerLoader({
        batch_get: async (ids_and_args) => data.{{ data.batch_get_referrer(referrer) }}(ids_and_args),
        entity_loader: () => {{ loader.entity(referrer.get_entity()) }},
        referrer_column: '{{ referrer.get_column_name() }}',
        name: '{{ loader.referrer(referrer) }}'
    });

    const {{ loader.count_referrer(referrer) }} = new ReferrerCountLoader({
        name: '{{ loader.count_referrer(referrer) }}',
        batch_get: async (ids_and_args) => data.{{ data.batch_count_referrer(referrer) }}(ids_and_args),
        referrer_column: '{{ referrer.get_column_name() }}'
    });
{%     endfor %}

{%     for association in entity.get_associations() %}
{%         if association.is_self_referential() %}
    const {{ loader.association_for_entity(entity, association) }} = new SelfReferentialAssociationLoader({
        batch_get: async (ids_and_args) => data.{{ data.batch_get_association(entity, association) }}(ids_and_args),
        lhs_column: '{{ arguments.lhs(association) }}',
        rhs_column: '{{ arguments.rhs(association) }}',
        name: '{{ loader.association_for_entity(entity, association) }}'
    });

{%         else %}
    const {{ loader.association_for_entity(entity, association) }} = new AssociationLoader({
        batch_get: async (ids_and_args) => data.{{ data.batch_get_association(entity, association) }}(ids_and_args),
        this_column: '{{ arguments.this_column(entity, association) }}',
        other_column: '{{ arguments.other_column(entity, association) }}',
        name: '{{ loader.association_for_entity(entity, association) }}'
    });
{%         endif %}
{%     endfor %}
{% endfor %}

    const clearAll = () => {
{% for entity in schema.get_entities() %}
        {{ loader.entity(entity) }}.clearAll();
        {{ loader.entities(entity) }}.clearAll();
{%     for referrer in entity.get_referrers() %}
        {{ loader.referrer(referrer) }}.clearAll();
        {{ loader.count_referrer(referrer) }}.clearAll();
{%     endfor %}
{%     for association in entity.get_associations() %}
        {{ loader.association_for_entity(entity, association) }}.clearAll();
{%     endfor %}
{% endfor %}
    };

    return {
{% for entity in schema.get_entities() %}
        {{ loader.entity(entity) }},
        {{ loader.entities(entity) }},
        {{ loader.count_entities(entity) }},
{%     for referrer in entity.get_referrers() %}
        {{ loader.referrer(referrer) }},
        {{ loader.count_referrer(referrer) }},
{%     endfor %}
{%     for association in entity.get_associations() %}
        {{ loader.association_for_entity(entity, association) }},
{%     endfor %}
{% endfor %}
        data,
        clearAll
    };
};