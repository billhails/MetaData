const sqlite3 = require('sqlite3').verbose();
const { open: openSqlite } = require('sqlite');
const util = require('util');
const Model = require('../Model');
const logger = require('./logger');

// {{ warning }}

{% import 'data.j2h' as data %}

class Data {
    constructor(db) {
        this.db = db;
        this.db.run('PRAGMA foreign_keys = ON');
    }

    async get(query, params) {
        logger.debug(`get: ${query} ${params}`);
        return this.db.get(query, params).catch(error => {
            logger.error(`${error} while executing ${query}, ${util.inspect(params)}`);
            throw(error);
        });
    }

    async run(query, params) {
        logger.debug(`run: ${query} ${params}`);
        return this.db.run(query, params).catch(error => {
            logger.error(`${error} while executing ${query}, ${util.inspect(params)}`);
            throw(error);
        });
    }

    async all(query, params) {
        logger.debug(`all: ${query} ${params}`);
        return this.db.all(query, params).catch(error => {
            logger.error(`${error} while executing ${query}, ${util.inspect(params)}`);
            throw(error);
        });
    }

{% for entity in schema.get_entities() %}
    /**
     * fetch entity
     *
     * @param {String} id
     * @returns {Model.{{ entity.get_name() }}}
     */
    async {{ data.get_entity(entity) }}(id) {
        logger.debug(`get_{{ entity.get_name() | singular }}_by_id(${util.inspect(id)})`);
        return this.get('SELECT * FROM {{ entity.get_name() }} WHERE id = ?', [id])
            .then(row => new Model.{{ entity.get_name() }}(row));
    }

    /**
     * batch fetch entities for loader
     *
     * @param {[String]} ids
     * @returns {[Model.{{ entity.get_name() }}]}
     */
    async {{ data.batch_get_entity(entity) }}(ids) {
        logger.debug(`{{ data.batch_get_entity(entity) }}(${util.inspect(ids)})`);
        const rows = await this.all(
            `SELECT * from {{ entity.get_name() }} WHERE id IN (${ Array(ids.length).fill('?').join(', ') })`,
            ids
        ).then(rows => rows.reduce((acc, row) => ({ ...acc, [row.id]: row }), {}));
        return ids.map(id => rows[id] ? new Model.{{ entity.get_name() }}(rows[id]) : null);
    }

    /**
     * fetch a page of entities
     *
     * @param {object} args
     * @returns {[Model.{{ entity.get_name() }}]}
     */
    async {{ data.page_get_entity(entity) }}(args) {
        const take = args.take || 20;
        const skip = args.skip || 0;
        return this.all(
            `SELECT * from {{ entity.get_name() }}
              LIMIT ?
             OFFSET ?
            `,
            [take, skip]
        ).then(rows => rows.map(row => new Model.{{ entity.get_name() }}(row)));
    }

{%     for union in entity.get_unions() %}
    /**
     * validate that an entry in the appropriate table exists
     *
     * @param {string} id
     * @param {string} type
     * @throws {Error}
     */
    async {{ data.validate_union(entity, union) }}(id, type) {
        let table;
        switch (type) {
{%        for reference in union.get_references() %}
            case "{{ reference.get_name() }}":
                table = "{{ reference.get_referenced().get_name() }}";
                break;
{%        endfor %}
        }
        const row = await this.get(`
                SELECT count(*) as c
                  FROM ${table}
                 WHERE id = ?
            `,
            [id]
        );

        if (parseInt(row.c) != 1) {
            throw new Error(`union {{ entity.get_name() }}.{{ union.get_name() }} reference failed, no ${type} with id ${id}`);
        }
    }
{%     endfor %}{# unions #}

    /**
     * insert entity
     *
     * @param {object} args
     * @returns {Model.{{ entity.get_name() }}}
     */
    async {{ data.create_entity(entity) }}(args) {
        const model = new Model.{{ entity.get_name() }}(args);
{%     for union in entity.get_unions() %}
        await this.{{ data.validate_union(entity, union) }}(model.{{ union.get_name() }}, model.{{ union.get_name() }}_type);
{%     endfor %}
        const sql = `
        INSERT INTO {{ entity.get_name() }}(
          id{% for field in entity.get_fields() %}, {{ field.get_name() }}{% endfor %}
          {%- for reference in entity.get_references() %}, {{ reference.get_name() }}{% endfor %}
          {%- for union in entity.get_unions() %}, {{ union.get_name() }}, {{ union.get_name() }}_type{% endfor %}
        )
        VALUES (?{{ ', ?' * ((entity.get_fields()|length) + (entity.get_references()|length) + 2*(entity.get_unions()|length)) }})
        `;
        const params = [
           model.id{% for field in entity.get_fields() %}, model.{{ field.get_name() }}{% endfor %}
          {%- for reference in entity.get_references() %}, model.{{ reference.get_name() }}{% endfor %}
          {%- for union in entity.get_unions() %}, model.{{ union.get_name() }}, model.{{ union.get_name() }}_type{% endfor %}
        ]
        await this.run(sql, params);
        return model;
    }

    /**
     * update entity
     *
     * @param {string} id
     * @param {object} args
     * @returns {Model.{{ entity.get_name() }}}
     */
    async {{ data.update_entity(entity) }}(id, args) {
        const model = new Model.{{ entity.get_name() }}({id, ...args});
{%     for union in entity.get_unions() %}
        if ("{{ union.get_name() }}" in model) {
            await this.{{ data.validate_union(entity, union) }}(model.{{ union.get_name() }}, model.{{ union.get_name() }}_type);
        }
{%     endfor %}

        const fields = [];
        const params = [];

{%     for field in entity.get_fields() %}
        if ('{{ field.get_name() }}' in args) {
            fields.push("{{ field.get_name() }} = ?");
            params.push(model.{{ field.get_name() }});
        }
{%     endfor %}
{%     for reference in entity.get_references() %}
        if ('{{ reference.get_name() }}' in args) {
            fields.push("{{ reference.get_name() }} = ?");
            params.push(model.{{ reference.get_name() }});
        }
{%     endfor %}
{%     for union in entity.get_unions() %}
        if ('{{ union.get_name() }}' in args) {
            fields.push("{{ union.get_name() }} = ?");
            params.push(model.{{ union.get_name() }});
            fields.push("{{ union.get_name() }}_type = ?");
            params.push(model.{{ union.get_name() }}_type);
        }
{%     endfor %}

        params.push(model.id);

        if (fields.length) {
            const sql = `
            UPDATE {{ entity.get_name() }} SET
            ${fields.join(', ')}
             WHERE id = ?
            `;

            await this.run(sql, params);
        }

        return this.{{ data.get_entity(entity) }}(id);
    }

    /**
     * delete entity
     *
     * @param {String} id
     */
    async {{ data.delete_entity(entity) }}(id) {
        return this.run('DELETE FROM {{ entity.get_name() }} WHERE id = ?', [id]).then(stats => stats.changes > 0);
    }

{%     for reference in entity.get_references() %}
    /**
     * fetch reference
     *
     * @param {Model.{{ entity.get_name() }}} model
     */
    async {{ data.get_reference_for_entity(entity, reference) }}(model) {
        return this.get('SELECT * FROM {{ reference.get_referenced().get_name() }} WHERE id = ?', [model.{{ reference.get_name() }}])
        .then(row => new Model.{{ reference.get_referenced().get_name() }}(row));
    }
{%     endfor %}

{%     for union in entity.get_unions() %}
    /**
     * fetch union
     *
     * @param {Model.{{ entity.get_name() }}} model
     */
    async {{ data.get_union_for_entity(entity, union) }}(model) {
        switch (model.{{ union.get_name() }}_type) {
{%         for reference in union.get_references() %}
            case '{{ reference.get_name() }}':
                return this.get(
                    'SELECT * FROM {{ reference.get_referenced().get_name() }} WHERE id = ?',
                    [model.{{ union.get_name() }}]
                ).then(row => new Model.{{ reference.get_referenced().get_name() }}(row));
{%         endfor %}
        }
    }
{%     endfor %}

{%     for referrer in entity.get_referrers() %}
    /**
     * fetch referrer
     *
     * @param {Model.{{ entity.get_name() }}} model
     */
    async {{ data.get_referrer_for_entity(entity, referrer) }}(model) {
        return this.all(
{%         if referrer.is_union() %}
            `SELECT * FROM {{ referrer.get_entity().get_name() }}
             WHERE {{ referrer.get_union().get_name() }} = ?
             AND {{ referrer.get_union().get_name() }}_type = "{{ referrer.get_name() }}"
             `,
{%         else %}
            'SELECT * FROM {{ referrer.get_entity().get_name() }} WHERE {{ referrer.get_name() }} = ?',
{%         endif %}
            [model.id]
        ).then(rows => rows.map(row => new Model.{{ referrer.get_entity().get_name() }}(row)));
    }

    /**
     * fetch referrers for loader
     *
     * @param {[string]} ids
     */
    async {{ data.batch_get_referrer(referrer) }}(ids_and_args) {
        logger.debug('{{ data.batch_get_referrer(referrer) }}(${util.inspect(ids_and_args)}');
        const subqueries = [];
        const args = [];
        ids_and_args.forEach(id_and_arg => {
            const limit = id_and_arg.args.take || 5;
            const offset = id_and_arg.args.skip || 0;
            const id = id_and_arg.id;
            const subquery = `
                SELECT * FROM (
{%         if referrer.is_union() %}
                SELECT * FROM {{ referrer.get_entity().get_name() }}
                 WHERE {{ referrer.get_union().get_name() }} = ?
                   AND {{ referrer.get_union().get_name() }}_type = "{{ referrer.get_name() }}"
{%         else %}
                SELECT * FROM {{ referrer.get_entity().get_name() }}
                 WHERE {{ referrer.get_name() }} = ?
{%         endif %}
                 LIMIT ?
                OFFSET ?
                )
            `;
            subqueries.push(subquery);
            args.push(id, limit, offset);
        });

        return this.all(subqueries.join('UNION ALL'), args).then(rows => rows.map(row => new Model.{{ referrer.get_entity().get_name() }}(row)));
    }
{%     endfor %}

{%     for association in entity.get_associations() %}
    /**
     * fetch association
     *
     * @param {Model.{{ entity.get_name() }}} model
     */
    async {{ data.get_association_for_entity(entity, association) }}(model) {
        return this.all(
{%         if association.is_self_referential() %}
            `
    SELECT {{ entity.get_name() }}.*
      FROM {{ association.get_name() }}
      JOIN {{ entity.get_name() }}
        ON {{ association.get_name() }}.{{ association.get_rhs_column() }} = {{ entity.get_name() }}.id
     WHERE {{ association.get_name() }}.{{ association.get_lhs_column() }} = ?
     UNION
    SELECT {{ entity.get_name() }}.*
      FROM {{ association.get_name() }}
      JOIN {{ entity.get_name() }}
        ON {{ association.get_name() }}.{{ association.get_lhs_column() }} = {{ entity.get_name() }}.id
     WHERE {{ association.get_name() }}.{{ association.get_rhs_column() }} = ?
            `,
            [model.id, model.id]
{%         else %}
            `
    SELECT {{ association.get_other(entity).get_name() }}.*
      FROM {{ association.get_name() }}
      JOIN {{ association.get_other(entity).get_name() }}
        ON {{ association.get_name() }}.{{ association.get_other_column(entity) }} = {{ association.get_other(entity).get_name() }}.id
     WHERE {{ association.get_name() }}.{{ association.get_this_column(entity) }} = ?
            `,
            [model.id]
{%         endif %}
        ).then(rows => rows.map(row => new Model.{{ association.get_other(entity).get_name() }}(row)));
    }

    /**
     * fetch associations for loader
     *
     * @param {[string]} ids
     */
    async {{ data.batch_get_association(entity, association) }}(ids_and_args) {
        logger.debug(`{{ data.batch_get_association(entity, association) }}(${util.inspect(ids_and_args)})`);
{%         if association.is_self_referential() %}
        const subqueries = [];
        const args = [];
        ids_and_args.forEach(id_and_arg => {
            const id = id_and_arg.id;
            const limit = id_and_arg.args.take || 5;
            const offset = id_and_arg.args.skip || 0;
            const subquery = `
            SELECT * FROM (
                SELECT *
                  FROM {{ association.get_name() }}
                 WHERE {{ association.get_lhs_column() }} = ?
                 LIMIT ?
                OFFSET ?
            )
            UNION ALL
            SELECT * FROM (
                SELECT *
                  FROM {{ association.get_name() }}
                 WHERE {{ association.get_rhs_column() }} = ?
                 LIMIT ?
                OFFSET ?
            )
            `;
            subqueries.push(subquery);
            args.push(id, limit, offset, id, limit, offset);
        });

        return this.all(subqueries.join('UNION ALL'), args);

{%         else %}

        const subqueries = [];
        const args = [];
        ids_and_args.forEach(id_and_arg => {
            const id = id_and_arg.id;
            const limit = id_and_arg.args.take || 5;
            const offset = id_and_arg.args.skip || 0;
            const subquery = `
            SELECT * FROM (
                SELECT *
                  FROM {{ association.get_name() }}
                 WHERE {{ association.get_this_column(entity) }} = ?
                 LIMIT ?
                OFFSET ?
            )
            `;
            subqueries.push(subquery);
            args.push(id, limit, offset);
        });
        return this.all(subqueries.join('UNION ALL'), args);
{%         endif %}
    }
{%     endfor %}

{% endfor %}

    static async build() {
        return openSqlite({
            filename: './{{ schema.get_name() }}.db',
            driver: sqlite3.Database
        }).then(db => new Data(db))
    }
}

module.exports = Data;